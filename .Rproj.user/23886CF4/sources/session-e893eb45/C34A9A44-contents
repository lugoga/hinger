---
title: "Untitled"
author: "Masumbuko Semba"
date: "2/28/2022"
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, comment = "")
```



```{r}
require(sf)
require(tidyverse)
require(patchwork)
require(magrittr)
require(tmap)
require(prophet)
require(ggspatial)

## basemap shapefile from tmap package
data("World")


# color codes
mycolor3 = c("#9000B0", "#C900B0", "#C760AF", "#1190F9", "#60C8F8", "#90C9F8", "#F8F8F8", "#F8F800",  "#F8D730", "#f8b030", "#f8602f", "#f80000")


```



```{r}
global = read_csv("../data/temperature_lss_global_1990_2020_2021.csv")
```


We need to create a Raster* object from a dataframe with longitude, latitude and z values. This can be faciliated with `rasterFromXYZ` function in **raster** package.  longitude  and latitude represent spatial coordinates and must be on a regular grid. If the resolution is not supplied, it is assumed to be the minimum distance between longitude and latitude coordinates, but a resolution of up to 10 times smaller is evaluated if a regular grid can otherwise not be created. Thus, we first create a raster layer of global temperature. This raster layer we will use for mapping the distribution of temperature in flat and spherical maps. 


```{r }
temperature = global %>% filter(year == 2021)

temperature.raster = temperature %>% 
  select(-year) %>% 
  raster::rasterFromXYZ(crs = 4326)
```

The function `coord_sf` allows to deal with the coordinate system, which includes both projection and extent of the map. By default, the map will use the coordinate system of the first layer that defines one (i.e. scanned in the order provided), or if none, fall back on WGS84 (latitude/longitude, the reference system used in GPS).  Since our dataset use WGS84, it will draw flatten map of temperature shown in figure \@ref(fig:temperature)

```{r temperature, fig.width=8, fig.cap="Flatten Global land and sea surface temperature anomaly for a year 2021 compared to to the 1950-1980 average"}

ggplot()+
  ggspatial::layer_spatial(data = temperature.raster)+
  ggspatial::layer_spatial(data = World, fill = NA)+
  coord_sf(xlim = c(-180,180), ylim = c(-70,70), crs = 4326)+
  scale_fill_gradientn(colours = mycolor3, 
                       trans = scales::modulus_trans(p = .1),
                       name = expression(T~(degree*C))) +
  theme_bw(base_size = 12)+
  theme(axis.title = element_blank())+
  metR::scale_x_longitude()+
  annotation_scale(location = "bl", width_hint = 0.25) +
  annotation_north_arrow(location = "bl", which_north = "true", 
        pad_x = unit(0.75, "in"), pad_y = unit(0.5, "in"),
        style = north_arrow_fancy_orienteering)
```
If we wish to change change shape of the map to spherical and to visualize in details areas with high temperature for the year 2021, we simply alter the `coord_sf` function. Using the argument crs, it is possible to override this setting, and project on the fly to any projection. This can be achieved using any valid PROJ4 string (here, the European-centric ETRS89 Lambert Azimuthal Equal-Area projection):



```{r temperature1, fig.width=8, fig.cap="Spherical Global land and sea surface temperature anomaly for a year 2021 compared to to the 1950-1980 average"}

europe = "+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +no_defs"

ggplot()+
  ggspatial::layer_spatial(data = temperature.raster)+
  ggspatial::layer_spatial(data = World, fill = NA)+
  coord_sf(crs = europe) +
  scale_fill_gradientn(colours = mycolor3, na.value = NA,
                       trans = scales::modulus_trans(p = .1),
                       name = expression(T~(degree*C))) +
  theme_bw(base_size = 12)+
  theme(axis.title = element_blank(), panel.background = element_blank())


```

Suppose we are interested in adjusting the projection and make africa popup. first we define the location, and then project coordinates from WGS84 to the specified, for instance in this case to UTM zone 37

```{r}
points = tibble(x = 55, y = -75) %>% 
  st_as_sf(coords = c("x", "y"), crs = 4326) %>% 
  st_transform(32737)

points %>% st_bbox()


```



Then use the easting (xmin) and northings (ymin) values into the projection and specify it in the coord_sf

```{r temperature1, fig.width=8, fig.cap="Spherical Global land and sea surface temperature anomaly for a year 2021 compared to to the 1950-1980 average"}

africa = "+proj=laea +lat_0=52 +lon_0=10 +x_0=957039 +y_0=1614295 +ellps=GRS80 +units=m +no_defs"

ggplot()+
  ggspatial::layer_spatial(data = temperature.raster)+
  ggspatial::layer_spatial(data = World, fill = NA)+
  coord_sf(crs = africa) +
  scale_fill_gradientn(colours = mycolor3, na.value = NA,
                       trans = scales::modulus_trans(p = .1),
                       name = expression(T~(degree*C))) +
  theme_bw(base_size = 12)+
  theme(axis.title = element_blank(), panel.background = element_blank())

```
